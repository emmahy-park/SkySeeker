#pragma once

// internal
#include "../common.hpp"

// stlib
#include <vector>
#include <random>

#define SDL_MAIN_HANDLED
#include <SDL.h>
#include <SDL_mixer.h>

#include "render_system.hpp"
#include "player_system.hpp"
#include "enemy_system.hpp"
#include "item_system.hpp"
#include "particle_system.hpp"
#include "upgrade_system.hpp"
#include "util/map_parser.hpp"
#include <deque>

// Container for all our entities and game logic.
// Individual rendering / updates are deferred to the update() methods.
class WorldSystem
{
public:
	WorldSystem();

	// creates main window
	GLFWwindow* create_window();

	// starts and loads music and sound effects
	bool start_and_load_sounds();

	// call to close the window
	void close_window();

	// starts the game
	void init(RenderSystem* renderer, PlayerSystem* player_system, EnemySystem* enemy_system, ItemSystem* item_system, ScreenManager* screen_manager, UpgradeSystem* upgrade_system, ParticleSystem* particle_system, AISystem* ai_system);

	// releases all associated resources
	~WorldSystem();

	// steps the game ahead by ms milliseconds
	bool step(float elapsed_ms, float actual_elapsed_ms);

	// check for collisions generated by the physics system
	void handle_collisions();

	// should the game be over ?
	bool is_over() const;

	void spawn_enemy_pack();
	void handle_enemy_killed(Entity enemy_entity);

	// restart level
	void restart_game();

	void change_background_music(ScreenManager& screen_manager);
	void play_sound_effect(std::string sound);

	void save_game_state();
	void load_game_state();

	static bool is_itempopup_visible;

private:

	unsigned int num_waves = 2;

	Entity* selected_item_entity = NULL;

	float mouse_pos_x = 0.0f;
	float mouse_pos_y = 0.0f;

	// input callback functions
	void on_key(int key, int, int action, int mod);
	void on_mouse_move(vec2 pos);
	void on_mouse_button_pressed(int button, int action, int mods);
	void handle_tile_collision(Entity& tile_entity, Entity& other_entity);
	void handle_exit_collision();

	void handle_item_player_collision(Entity& item_entity, Entity& player_entity);
	void handle_friendly_collision(Entity& entity0, Entity& entity1);
	void handle_enemy_attack_collision(Entity& enemy_entity, Entity& other);
	void handle_sword_collision(Entity& sword_entity, Entity& enemy_entity);
	void handle_all_enemies_killed();

	void handle_projectile_collision(Entity& projectile_entity, Entity& other);
	void deal_damage(Entity& attacker, Entity& attacked, bool is_special, float damage_multiplier);
	bool collide_triangle(Entity& entity, Entity& other);

	void handle_parry_collision(Entity& parry_entity, Entity& other);

	void step_projectile(float elapsed_ms);

	void updateHealthbarPosition(Entity e, vec2 camera_position);

	bool is_player_alive();

	// OpenGL window handle
	GLFWwindow* window;

	int next_invader_spawn;
	int invader_spawn_rate_ms;	// see default value in common.hpp

	int max_towers;	// see default value in common.hpp

	// Number of invaders stopped by the towers, displayed in the window title
	unsigned int points;

	// Game state
	RenderSystem* renderer;
	PlayerSystem* player_system;
	EnemySystem* enemy_system;
	ItemSystem* item_system;
	UpgradeSystem* upgrade_system;
	ScreenManager* screen_manager;
	ParticleSystem* particle_system;
	AISystem* ai_system;
	float current_speed;

	// FPS
	int frames_since_last_second = 0;
	float time_since_last_second = 0;
	int fps_counter = 0;

	Entity game_state_entity;

	// grid
	std::vector<Entity> grid_lines;

	// music references
	Mix_Music* background_start_music;
	Mix_Music* background_game_music;
	Mix_Music* background_paused_music;
	Mix_Chunk* sword_swing_sound;
	Mix_Chunk* laser_sound;
	Mix_Chunk* souls_pickup;
	Mix_Chunk* item_equip;
	Mix_Chunk* menu_change;
	Mix_Chunk* enter;
	Mix_Chunk* parry;
	Mix_Chunk* dash;
	Mix_Music* current_music = background_start_music;

	// C++ random number generator
	std::default_random_engine rng;
	std::uniform_real_distribution<float> uniform_dist; // number between 0..1
};
